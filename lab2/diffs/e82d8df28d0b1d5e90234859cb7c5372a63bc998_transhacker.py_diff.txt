@@ -1,8 +1,94 @@
-# Transposition Cipher Hacker
-# http://inventwithpython.com/hacking (BSD Licensed)
+"""
+ ██████╗██╗██████╗ ██╗  ██╗███████╗██╗   ██╗
+██╔════╝██║██╔══██╗██║  ██║██╔════╝╚██╗ ██╔╝
+██║     ██║██████╔╝███████║█████╗   ╚████╔╝ 
+██║     ██║██╔═══╝ ██╔══██║██╔══╝    ╚██╔╝  
+╚██████╗██║██║     ██║  ██║███████╗   ██║ 
+© Brandon Skerritt
+https://github.com/brandonskerritt/ciphey
+"""
 
 import transpositionDecrypt
 import math
+class Transposition:
+    def __init__(lc):
+        self.lc = lc
+    def hackTransposition(self, message):
+        print('Hacking...')
+
+        # Python programs can be stopped at any time by pressing Ctrl-C (on
+        # Windows) or Ctrl-D (on Mac and Linux)
+        print('(Press Ctrl-C or Ctrl-D to quit at any time.)')
+
+        # brute-force by looping through every possible key
+        for key in range(1, len(message)):
+            print('Trying key #%s...' % (key))
+            decryptedText = decryptMessage(key, message)
+            print()
+            print('Possible encryption hack:')
+            print('Key %s: %s' % (key, decryptedText[:100]))
+            print()
+            print('Enter D for done, or just press Enter to continue hacking:')
+            response = input('> ')
+
+            if response.strip().upper().startswith('D'):
+                return decryptedText
+
+        return None
+    def hackTransposition(self, message):
+        print('Hacking...')
+
+        # Python programs can be stopped at any time by pressing Ctrl-C (on
+        # Windows) or Ctrl-D (on Mac and Linux)
+        print('(Press Ctrl-C or Ctrl-D to quit at any time.)')
+
+        # brute-force by looping through every possible key
+        for key in range(1, len(message)):
+            print('Trying key #%s...' % (key))
+            decryptedText = self.decryptMessage(key, message)
+            print()
+            print('Possible encryption hack:')
+            print('Key %s: %s' % (key, decryptedText[:100]))
+            print()
+            print('Enter D for done, or just press Enter to continue hacking:')
+            response = input('> ')
+
+            if response.strip().upper().startswith('D'):
+                return decryptedText
+
+        return None
+
+    def decryptMessage(self, key, message):
+        # The transposition decrypt function will simulate the "columns" and
+        # "rows" of the grid that the plaintext is written on by using a list
+        # of strings. First, we need to calculate a few values.
+
+        # The number of "columns" in our transposition grid:
+        numOfColumns = math.ceil(len(message) / key)
+        # The number of "rows" in our grid will need:
+        numOfRows = key
+        # The number of "shaded boxes" in the last "column" of the grid:
+        numOfShadedBoxes = (numOfColumns * numOfRows) - len(message)
+
+        # Each string in plaintext represents a column in the grid.
+        plaintext = [''] * numOfColumns
+
+        # The col and row variables point to where in the grid the next
+        # character in the encrypted message will go.
+        col = 0
+        row = 0
+
+        for symbol in message:
+            plaintext[col] += symbol
+            col += 1 # point to next column
+
+            # If there are no more columns OR we're at a shaded box, go back to
+            # the first column and the next row.
+            if (col == numOfColumns) or (col == numOfColumns - 1 and row >= numOfRows - numOfShadedBoxes):
+                col = 0
+                row += 1
+
+        return ''.join(plaintext)
 
 def main():
     # You might want to copy & paste this text from the source code at
@@ -17,61 +103,5 @@ def main():
         print('Copying hacked message to clipboard:')
         print(hackedMessage)
 
-
-def hackTransposition(message):
-    print('Hacking...')
-
-    # Python programs can be stopped at any time by pressing Ctrl-C (on
-    # Windows) or Ctrl-D (on Mac and Linux)
-    print('(Press Ctrl-C or Ctrl-D to quit at any time.)')
-
-    # brute-force by looping through every possible key
-    for key in range(1, len(message)):
-        print('Trying key #%s...' % (key))
-        decryptedText = decryptMessage(key, message)
-        print()
-        print('Possible encryption hack:')
-        print('Key %s: %s' % (key, decryptedText[:100]))
-        print()
-        print('Enter D for done, or just press Enter to continue hacking:')
-        response = input('> ')
-
-        if response.strip().upper().startswith('D'):
-            return decryptedText
-
-    return None
-
-def decryptMessage(key, message):
-    # The transposition decrypt function will simulate the "columns" and
-    # "rows" of the grid that the plaintext is written on by using a list
-    # of strings. First, we need to calculate a few values.
-
-    # The number of "columns" in our transposition grid:
-    numOfColumns = math.ceil(len(message) / key)
-    # The number of "rows" in our grid will need:
-    numOfRows = key
-    # The number of "shaded boxes" in the last "column" of the grid:
-    numOfShadedBoxes = (numOfColumns * numOfRows) - len(message)
-
-    # Each string in plaintext represents a column in the grid.
-    plaintext = [''] * numOfColumns
-
-    # The col and row variables point to where in the grid the next
-    # character in the encrypted message will go.
-    col = 0
-    row = 0
-
-    for symbol in message:
-        plaintext[col] += symbol
-        col += 1 # point to next column
-
-        # If there are no more columns OR we're at a shaded box, go back to
-        # the first column and the next row.
-        if (col == numOfColumns) or (col == numOfColumns - 1 and row >= numOfRows - numOfShadedBoxes):
-            col = 0
-            row += 1
-
-    return ''.join(plaintext)
-
 if __name__ == '__main__':
     main()
\ No newline at end of file
