@@ -25,7 +25,7 @@ logger.add(
 )
 warnings.filterwarnings("ignore")
 
-# Depening on whether ciphey is called, or ciphey/__main__
+# Depending on whether Ciphey is called, or Ciphey/__main__
 # we need different imports to deal with both cases
 try:
     from languageCheckerMod import LanguageChecker as lc
@@ -56,68 +56,79 @@ class Ciphey:
         self.lc = lc.LanguageChecker()
         self.mh = mh.mathsHelper()
         # the one bit of text given to us to decrypt
-        self.text = text
+        self.text: str = text
         logger.debug(f"The inputted text at __main__ is {self.text}")
-        # the decryptor components
         self.basic = BasicParent(self.lc)
         self.hash = HashParent()
         self.encoding = EncodingParent(self.lc)
-        self.level = 1
-        self.sickomode = False
-        self.greppable = grep
+        self.level: int = 1
+        self.sickomode: bool = False
+        self.greppable: bool = grep
         self.cipher = cipher
         self.console = Console()
+        self.probability_distribution: dict = {}
+        self.what_to_choose: dict = {}
 
-    def decrypt(self):
+    def decrypt(self) -> None:
+        """Performs the decryption of text
+
+        Creates the probability table, calls one_level_of_decryption
+
+        Args:
+            None, it uses class variables.
+
+        Returns:
+            None
+        """
         # Read the documentation for more on this function.
         # checks to see if inputted text is plaintext
         result = self.lc.checkLanguage(self.text)
         if result:
             print("You inputted plain text!")
             return None
-        self.probabilityDistribution = self.ai.predictnn(self.text)[0]
-        self.whatToChoose = {
+        self.probability_distribution: dict = self.ai.predictnn(self.text)[0]
+        self.what_to_choose: dict = {
             self.hash: {
-                "sha1": self.probabilityDistribution[0],
-                "md5": self.probabilityDistribution[1],
-                "sha256": self.probabilityDistribution[2],
-                "sha512": self.probabilityDistribution[3],
+                "sha1": self.probability_distribution[0],
+                "md5": self.probability_distribution[1],
+                "sha256": self.probability_distribution[2],
+                "sha512": self.probability_distribution[3],
             },
-            self.basic: {"caesar": self.probabilityDistribution[4]},
-            "plaintext": {"plaintext": self.probabilityDistribution[5]},
+            self.basic: {"caesar": self.probability_distribution[4]},
+            "plaintext": {"plaintext": self.probability_distribution[5]},
             self.encoding: {
-                "reverse": self.probabilityDistribution[6],
-                "base64": self.probabilityDistribution[7],
-                "binary": self.probabilityDistribution[8],
-                "hexadecimal": self.probabilityDistribution[9],
-                "ascii": self.probabilityDistribution[10],
-                "morse": self.probabilityDistribution[11],
+                "reverse": self.probability_distribution[6],
+                "base64": self.probability_distribution[7],
+                "binary": self.probability_distribution[8],
+                "hexadecimal": self.probability_distribution[9],
+                "ascii": self.probability_distribution[10],
+                "morse": self.probability_distribution[11],
             },
         }
 
         logger.debug(
-            f"The probability table before 0.1 in __main__ is {self.whatToChoose}"
+            f"The probability table before 0.1 in __main__ is {self.what_to_choose}"
         )
 
-        # sorts each indiviudal sub-dictionary
-        for key, value in self.whatToChoose.items():
+        # sorts each individual sub-dictionary
+        for key, value in self.what_to_choose.items():
             for k, v in value.items():
                 # Sets all 0 probabilities to 0.01, we want Ciphey to try all decryptions.
                 if v < 0.01:
-                    self.whatToChoose[key][k] = 0.01
+                    self.what_to_choose[key][k] = 0.01
         logger.debug(
-            f"The probability table after 0.1 in __main__ is {self.whatToChoose}"
+            f"The probability table after 0.1 in __main__ is {self.what_to_choose}"
         )
 
-        self.whatToChoose = self.mh.sortProbTable(self.whatToChoose)
+        self.what_to_choose: dict = self.mh.sort_prob_table(self.what_to_choose)
 
         # Creates and prints the probability table
-        if self.greppable == False:
+        if not self.greppable:
             logger.debug(f"Self.greppable is {self.greppable}")
-            self.produceProbTable(self.whatToChoose)
+            self.produceprobtable(self.what_to_choose)
 
         logger.debug(
-            f"The new probability table after sorting in __main__ is {self.whatToChoose}"
+            f"The new probability table after sorting in __main__ is {self.what_to_choose}"
         )
 
         """
@@ -138,11 +149,16 @@ class Ciphey:
                 pass
         return None
 
-    def produceProbTable(self, probTable):
+    def produceprobtable(self, prob_table) -> None:
         """Produces the probability table using Rich's API
 
-        :probTable: the probability distribution table returned by the neural network
-        :returns: Nothing, it prints out the prob table.
+        Uses Rich's API to print the probability table.
+
+        Args:
+            prob_table -> the probability table generated by the neural network
+
+        Returns:
+            None, but prints the probability table.
 
         """
         logger.debug(f"Producing log table")
@@ -152,46 +168,68 @@ class Ciphey:
         # for every key, value in dict add a row
         # I think key is self.caesarcipher and not "caesar cipher"
         # i must callName() somewhere else in this code
-        sortedDic = {}
-        for k, v in probTable.items():
+        sorted_dic: dict = {}
+        for k, v in prob_table.items():
             for key, value in v.items():
                 # Prevents the table from showing pointless 0.01 probs as they're faked
                 if value == 0.01:
                     continue
                 logger.debug(f"Key is {str(key)} and value is {str(value)}")
-                valInt = round(self.mh.percentage(value, 1), 2)
-                keyStr = str(key).capitalize()
-                if "Base" in keyStr:
-                    keyStr = keyStr[0:-2]
-                sortedDic[keyStr] = valInt
-                logger.debug(f"The value as percentage is {valInt} and key is {keyStr}")
-        sortedDic = {
+                val: int = round(self.mh.percentage(value, 1), 2)
+                key_str: str = str(key).capitalize()
+                if "Base" in key_str:
+                    key_str = key_str[0:-2]
+                sorted_dic[key_str] = val
+                logger.debug(f"The value as percentage is {val} and key is {key_str}")
+        sorted_dic: dict = {
             k: v
             for k, v in sorted(
-                sortedDic.items(), key=lambda item: item[1], reverse=True
+                sorted_dic.items(), key=lambda item: item[1], reverse=True
             )
         }
-        for k, v in sortedDic.items():
+        for k, v in sorted_dic.items():
             table.add_row(k, str(v) + "%")
+
         self.console.print(table)
+        return None
+
+    def one_level_of_decryption(self) -> None:
+        """Performs one level of encryption.
+
+        Either uses alive_bar or not depending on if self.greppable is set.
 
-    def one_level_of_decryption(self, file=None, sickomode=None):
+        Returns:
+            None.
+
+        """
         # Calls one level of decryption
         # mainly used to control the progress bar
         if self.greppable:
             logger.debug("__main__ is running as greppable")
-            self.decryptNormal()
+            self.decrypt_normal()
         else:
             with alive_bar() as bar:
                 logger.debug("__main__ is running with progress bar")
-                self.decryptNormal(bar)
+                self.decrypt_normal(bar)
+        return None
+
+    def decrypt_normal(self, bar=None) -> None:
+        """Called by one_level_of_decryption
+
+        Performs a decryption, but mainly parses the internal data packet and prints useful information.
 
-    def decryptNormal(self, bar=None):
-        for key, val in self.whatToChoose.items():
+        Args:
+            bar -> whether or not to use alive_Bar
+
+        Returns:
+            None, but prints.
+
+        """
+        for key, val in self.what_to_choose.items():
             # https://stackoverflow.com/questions/4843173/how-to-check-if-type-of-a-variable-is-string
             if not isinstance(key, str):
                 key.setProbTable(val)
-                ret = key.decrypt(self.text)
+                ret: dict = key.decrypt(self.text)
                 logger.debug(f"Decrypt normal in __main__ ret is {ret}")
                 logger.debug(
                     f"The plaintext is {ret['Plaintext']} and the extra information is {ret['Cipher']} and {ret['Extra Information']}"
@@ -200,7 +238,7 @@ class Ciphey:
                 if ret["IsPlaintext?"]:
                     print(ret["Plaintext"])
                     if self.cipher:
-                        if ret["Extra Information"] != None:
+                        if ret["Extra Information"] is not None:
                             print(
                                 "The cipher used is",
                                 ret["Cipher"] + ".",
@@ -220,10 +258,10 @@ class Ciphey:
                 * If Ciphey think's it's a hash, try using hash-identifier to find out what hash it is, and then HashCat to crack the hash.
                 * The encryption may not contain normal English plaintext. It could be coordinates or another object no found in the dictionary. Use 'ciphey -d true > log.txt' to generate a log file of all attempted decryptions and manually search it."""
         )
+        return None
 
 
 def main():
-
     parser = argparse.ArgumentParser(
         description="""Automated decryption tool. Put in the encrypted text and Ciphey will decrypt it.\n
         Examples:
@@ -285,7 +323,7 @@ def main():
     # if no data is supplied, no arguments supplied.
     if args["text"]:
         text = args["text"]
-    if args["text"] == None and len(sys.argv) > 1:
+    if args["text"] is None and len(sys.argv) > 1:
         text = args["rest"][0]
         print(f"text is {text}")
     if not sys.stdin.isatty():
@@ -293,9 +331,9 @@ def main():
     if len(sys.argv) == 1 and text == None:
         print("No arguments were supplied. Look at the help menu with -h or --help")
 
-    if text != None:
-        cipherObj = Ciphey(text, greppable, cipher, debug)
-        cipherObj.decrypt()
+    if text is not None:
+        cipher_obj = Ciphey(text, greppable, cipher, debug)
+        cipher_obj.decrypt()
 
 
 if __name__ == "__main__":
