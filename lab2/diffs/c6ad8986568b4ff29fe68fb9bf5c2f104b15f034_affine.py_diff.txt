@@ -14,6 +14,16 @@ from ciphey.mathsHelper import mathsHelper
 
 @registry.register
 class Affine(Cracker[str]):
+    """
+    Each character in the Affine Cipher is encoded with the rule E(x) = (ax + b) mod m
+    m is the size of the alphabet, while a and b are the keys in the cipher. a must be coprime to b.
+    The Caesar cipher is a specific case of the Affine Cipher, with a=1 and b being the shift of the cipher.
+    Decrypton is performed by D(x) = a_inv (x - b) mod m where a_inv is the modular multiplicative inverse of a mod m.
+
+    In this version of the Affine Cipher, we do not allow alphabets with several instances of the same letter in different cases.
+    For instance, the alphabet 'ABCdef123' is allowed, but 'AaBbCc' is not.
+    """
+
     def getInfo(self, ctext: str) -> CrackInfo:
         return CrackInfo(
             success_likelihood=0.1,
@@ -28,17 +38,11 @@ class Affine(Cracker[str]):
     def attemptCrack(self, ctext: str) -> List[CrackResult]:
         """
         Brute forces all the possible combinations of a and b to attempt to crack the cipher.
-        Each character in the Affine Cipher is encoded with the rule E(x) = (ax + b) mod m
-        m is the size of the alphabet, while a and b are the keys in the cipher. a must be coprime to b.
-        The Caesar cipher is a specific case of the Affine Cipher, with a=1 and b being the shift of the cipher.
-        Decrypton is performed by D(x) = a_inv (x - b) mod m where a_inv is the modular multiplicative inverse of a mod m.
+
         """
         logger.trace("Attempting Affine brute force.")
         candidates = []
 
-        # Convert the ctext to all-lowercase
-        ctext = ctext.lower()
-
         # a and b are coprime if gcd(a,b) is 1.
         possible_a = [
             a
@@ -48,13 +52,16 @@ class Affine(Cracker[str]):
         logger.debug(
             f"Trying Affine Cracker with {len(possible_a)} a-values and {self.ALPHABET_LENGTH} b-values"
         )
+
         for a in possible_a:
             a_inv = mathsHelper.mod_inv(a, self.ALPHABET_LENGTH)
             # If there is no inverse, we cannot decrypt the text
             if a_inv is None:
                 continue
             for b in range(self.ALPHABET_LENGTH):
-                translated = self.decrypt(ctext, a_inv, b, self.ALPHABET_LENGTH)
+                # Pass in lowered text. This means that we expect alfabets to not contain both 'a' and 'A'.
+                # Both are
+                translated = self.decrypt(ctext.lower(), a_inv, b, self.ALPHABET_LENGTH)
                 candidates.append(
                     CrackResult(
                         value=fix_case(translated, ctext), key_info=f"a={a}, b={b}"
@@ -72,6 +79,11 @@ class Affine(Cracker[str]):
         return "".join([self.decryptChar(char, a_inv, b, m) for char in text])
 
     def decryptChar(self, char: str, a_inv: int, b: int, m: int) -> str:
+
+        # We lower the alphabet since both ctext and alphabet need to be in the same case in order
+        # to perform the shifts. The translated text will have fixed case after the translation anyways.
+        alphabet = [x.lower() for x in self.group]
+
         # Preserve characters that are not in alphabet
         if char not in self.group:
             return char
