@@ -106,18 +106,23 @@ class Vigenere(ciphey.iface.Cracker[str]):
             )
         else:
             arrs = []
-            possible_len = self.kasiskiExamination(message)
-            possible_len.sort()
-            logger.trace(f"Got possible lengths {possible_len}")
+            likely_lens = self.cache.get_or_update(
+                ctext,
+                f"vigenere::likely_lens",
+                lambda: cipheycore.vigenere_likely_key_lens(ctext, self.expected, self.group),
+            )
+            possible_lens = [i for i in likely_lens]
+            possible_lens.sort(key=lambda i: i.p_value)
+            logger.trace(f"Got possible lengths {[i.len for i in likely_lens]}")
             # TODO: work out length
-            for i in possible_len:
+            for i in possible_lens:
                 arrs.extend(
                     self.crackOne(
                         message,
                         self.cache.get_or_update(
                             ctext,
-                            f"vigenere::{i}",
-                            lambda: cipheycore.analyse_string(ctext, i, self.group),
+                            f"vigenere::{i.len}",
+                            lambda: cipheycore.analyse_string(ctext, i.len, self.group),
                         ),
                     )
                 )
@@ -166,122 +171,4 @@ class Vigenere(ciphey.iface.Cracker[str]):
         if self.keysize is not None:
             self.keysize = int(self.keysize)
         self.p_value = self._params()["p_value"]
-        self.MAX_KEY_LENGTH = 16
-
-    def kasiskiExamination(self, ciphertext) -> List[int]:
-        likely_lens = self.cache.get_or_update(
-            ciphertext,
-            f"vigenere::likely_lens",
-            lambda: cipheycore.vigenere_likely_key_lens(ciphertext, self.expected, self.group),
-        )
-        return [i.len for i in likely_lens]
-
-        max = len(ciphertext) // 3
-
-        # Find out the sequences of 3 to 5 letters that occur multiple times
-        # in the ciphertext. repeatedSeqSpacings has a value like:
-        # {'EXG': [192], 'NAF': [339, 972, 633], ... }
-        repeatedSeqSpacings = self.findRepeatSequencesSpacings(ciphertext)
-
-        # (See getMostCommonFactors() for a description of seqFactors.)
-        seqFactors = {}
-        for seq in repeatedSeqSpacings:
-            seqFactors[seq] = []
-            for spacing in repeatedSeqSpacings[seq]:
-                seqFactors[seq].extend(self.getUsefulFactors(spacing, max))
-
-        # (See getMostCommonFactors() for a description of factorsByCount.)
-        factorsByCount = self.getMostCommonFactors(seqFactors)
-
-        # Now we extract the factor counts from factorsByCount and
-        # put them in allLikelyKeyLengths so that they are easier to
-        # use later:
-        allLikelyKeyLengths = []
-        for twoIntTuple in factorsByCount:
-            allLikelyKeyLengths.append(twoIntTuple[0])
-
-        # FIXME: This is a nasty hack to get it to work
-        if len(allLikelyKeyLengths) == 0 or True:
-            return list(range(2, max))
-
-        return allLikelyKeyLengths
-
-    def findRepeatSequencesSpacings(self, message):
-        # Goes through the message and finds any 3 to 5 letter sequences
-        # that are repeated. Returns a dict with the keys of the sequence and
-        # values of a list of spacings (num of letters between the repeats).
-        # Use a regular expression to remove non-letters from the message:
-
-        # Compile a list of seqLen-letter sequences found in the message:
-        seqSpacings = {}  # Keys are sequences, values are lists of int spacings.
-        for seqLen in range(3, 6):
-            for seqStart in range(len(message) - seqLen):
-                # Determine what the sequence is, and store it in seq:
-                seq = message[seqStart : seqStart + seqLen]
-
-                # Look for this sequence in the rest of the message:
-                for i in range(seqStart + seqLen, len(message) - seqLen):
-                    if message[i : i + seqLen] == seq:
-                        # Found a repeated sequence.
-                        if seq not in seqSpacings:
-                            seqSpacings[seq] = []  # Initialize a blank list.
-
-                        # Append the spacing distance between the repeated
-                        # sequence and the original sequence:
-                        seqSpacings[seq].append(i - seqStart)
-        return seqSpacings
-
-    def getUsefulFactors(self, num, max: int):
-        # Returns a list of useful factors of num. By "useful" we mean factors
-        # less than MAX_KEY_LENGTH + 1 and not 1. For example,
-        # getUsefulFactors(144) returns [2, 3, 4, 6, 8, 9, 12, 16]
-
-        if num < 2:
-            return []  # Numbers less than 2 have no useful factors.
-
-        factors = set()  # The list of factors found.
-
-        # When finding factors, you only need to check the integers up to
-        # MAX_KEY_LENGTH.
-        #
-        # Mathematician note: whilst this is *definitely* suboptimal,
-        # for small numbers it's probably as good as other methods
-        for i in range(
-            2, min(max, num)
-        ):  # Don't test 1: it's not useful.
-            if num % i == 0:
-                factors.add(i)
-                otherFactor = num // i
-                if otherFactor < self.MAX_KEY_LENGTH + 1 and otherFactor != 1:
-                    factors.add(otherFactor)
-        return list(factors)
-
-    #
-    def getMostCommonFactors(self, seqFactors):
-        # First, get a count of how many times a factor occurs in seqFactors:
-        factorCounts = {}  # Key is a factor, value is how often it occurs.
-
-        # seqFactors keys are sequences, values are lists of factors of the
-        # spacings. seqFactors has a value like: {'GFD': [2, 3, 4, 6, 9, 12,
-        # 18, 23, 36, 46, 69, 92, 138, 207], 'ALW': [2, 3, 4, 6, ...], ...}
-        for seq in seqFactors:
-            factorList = seqFactors[seq]
-            for factor in factorList:
-                if factor not in factorCounts:
-                    factorCounts[factor] = 0
-                factorCounts[factor] += 1
-
-        # Second, put the factor and its count into a tuple, and make a list
-        # of these tuples so we can sort them:
-        factorsByCount = []
-        for factor in factorCounts:
-            # Exclude factors larger than MAX_KEY_LENGTH:
-            if factor <= self.MAX_KEY_LENGTH:
-                # factorsByCount is a list of tuples: (factor, factorCount)
-                # factorsByCount has a value like: [(3, 497), (2, 487), ...]
-                factorsByCount.append((factor, factorCounts[factor]))
-
-        # Sort the list by the factor count:
-        factorsByCount.sort(key=lambda x: x[1], reverse=True)
-
-        return factorsByCount
+        self.MAX_KEY_LENGTH = 16
\ No newline at end of file
