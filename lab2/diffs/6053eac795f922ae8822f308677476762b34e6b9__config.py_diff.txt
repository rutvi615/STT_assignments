@@ -5,7 +5,8 @@ from typing import Any, Callable, Dict, List, Optional, Type, Union
 
 import appdirs
 import yaml
-from loguru import logger
+import logging
+from rich.logging import RichHandler
 
 from . import _fwd
 from ._modules import PolymorphicChecker, ResourceLoader, Searcher
@@ -19,14 +20,14 @@ class Cache:
 
     def mark_ctext(self, ctext: Any) -> bool:
         if (isinstance(ctext, str) or isinstance(ctext, bytes)) and len(ctext) < 4:
-            logger.trace(f"Candidate {ctext.__repr__()} too short!")
+            logging.debug(f"Candidate {ctext.__repr__()} too short!")
             return False
 
         if ctext in self._cache:
-            logger.trace(f"Deduped {ctext.__repr__()}")
+            logging.debug(f"Deduped {ctext.__repr__()}")
             return False
 
-        logger.trace(f"New ctext {ctext.__repr__()}")
+        logging.debug(f"New ctext {ctext.__repr__()}")
 
         self._cache[ctext] = {}
         return True
@@ -127,7 +128,7 @@ class Config:
         self.objs["format"] = pydoc.locate(self.format)
 
         # Checkers do not depend on any other config object
-        logger.trace(f"Registry is {_fwd.registry._reg[PolymorphicChecker]}")
+        logging.debug(f"Registry is {_fwd.registry._reg[PolymorphicChecker]}")
         self.objs["checker"] = self(
             _fwd.registry.get_named(self.checker, PolymorphicChecker)
         )
@@ -138,40 +139,22 @@ class Config:
         if verbosity is None:
             return
         self.verbosity = verbosity
-        quiet_list = [
-            "ERROR",
-            "CRITICAL",
-        ]
-        loud_list = ["DEBUG", "TRACE"]
-        verbosity_name: str
+
         if verbosity == 0:
-            verbosity_name = "WARNING"
+            self.verbosity = logging.WARNING
         elif verbosity >= 0:
-            verbosity_name = loud_list[min(len(loud_list), verbosity) - 1]
+            self.verbosity = logging.DEBUG
         else:
-            verbosity_name = quiet_list[min(len(quiet_list), -verbosity) - 1]
-
-        import sys
-
-        from loguru import logger
-
-        logger.remove()
-        if self.verbosity is None:
+            logging.disable(logging.CRITICAL)
             return
-        logger.configure()
-        if self.verbosity > 0:
-            logger.add(
-                sink=sys.stderr, level=verbosity_name, colorize=sys.stderr.isatty()
-            )
-            logger.opt(colors=True)
-        else:
-            logger.add(
-                sink=sys.stderr,
-                level=verbosity_name,
-                colorize=False,
-                format="{message}",
-            )
-        logger.debug(f"Verbosity set to level {verbosity} ({verbosity_name})")
+
+        # https://rich.readthedocs.io/en/latest/logging.html for more on RichHandler
+        logging.basicConfig(
+            level=self.verbosity,
+            datefmt="[%X]",
+            handlers=[RichHandler(markup=True, rich_tracebacks=True)],
+        )
+        logging.debug(f"Verbosity set to level {verbosity}")
 
     def load_modules(self):
         import importlib.util
@@ -181,7 +164,7 @@ class Config:
             mod = importlib.util.module_from_spec(spec)
             spec.loader.exec_module(mod)
 
-        logger.debug(f"Loaded modules {_fwd.registry.get_all_names()}")
+        logging.info(f"Loaded modules {_fwd.registry.get_all_names()}")
 
     def complete_config(self) -> "Config":
         """This does all the loading for the config, and then returns itself"""
@@ -191,7 +174,7 @@ class Config:
         return self
 
     def get_resource(self, res_name: str, t: Optional[Type] = None) -> Any:
-        logger.trace(f"Loading resource {res_name} of type {t}")
+        logging.debug(f"Loading resource {res_name} of type {t}")
 
         # FIXME: Actually returns obj of type `t`, but python is bad
         loader, name = split_resource_name(res_name)
