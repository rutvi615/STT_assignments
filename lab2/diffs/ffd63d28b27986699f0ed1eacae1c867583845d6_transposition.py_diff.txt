@@ -4,76 +4,81 @@ class Transposition:
     def __init__(self, lc):
         self.lc = lc
     def main(self):
-        myMessage = """AaKoosoeDe5 b5sn ma reno ora'lhlrrceey e  enlh
-                na  indeit n uhoretrm au ieu v er Ne2 gmanw,forwnlbsya apor tE.no
-                euarisfatt  e mealefedhsppmgAnlnoe(c -or)alat r lw o eb  nglom,Ain
-                one dtes ilhetcdba. t tg eturmudg,tfl1e1 v  nitiaicynhrCsaemie-sp
-                ncgHt nie cetrgmnoa yc r,ieaa  toesa- e a0m82e1w shcnth  ekh
-                gaecnpeutaaieetgn iodhso d ro hAe snrsfcegrt NCsLc b17m8aEheideikfr
-                aBercaeu thllnrshicwsg etriebruaisss  d iorr."""
+        myMessage = """Cb b rssti aieih rooaopbrtnsceee er es no npfgcwu  plri
+
+        ch nitaalr eiuengiteehb(e1  hilincegeoamn fubehgtarndcstudmd nM eu eacBoltaetee
+        
+        oinebcdkyremdteghn.aa2r81a condari fmps" tad   l t oisn sit u1rnd stara nvhn fs
+        
+        edbh ee,n  e necrg6  8nmisv l nc muiftegiitm tutmg cm shSs9fcie ebintcaets h  a
+        
+        ihda cctrhe ele 1O7 aaoem waoaatdahretnhechaopnooeapece9etfncdbgsoeb uuteitgna.
+        
+        rteoh add e,D7c1Etnpneehtn beete" evecoal lsfmcrl iu1cifgo ai. sl1rchdnheev sh
+        
+        meBd ies e9t)nh,htcnoecplrrh ,ide hmtlme. pheaLem,toeinfgn t e9yce da' eN eMp a
+        
+        ffn Fc1o ge eohg dere.eec s nfap yox hla yon. lnrnsreaBoa t,e eitsw il ulpbdofg
+        
+        BRe bwlmprraio po  droB wtinue r Pieno nc ayieeto'lulcih sfnc  ownaSserbereiaSm
+        
+        -eaiah, nnrttgcC  maciiritvledastinideI  nn rms iehn tsigaBmuoetcetias rn"""
     
         hackedMessage = self.hackTransposition(myMessage)
-    
-        if hackedMessage == None:
-            print('Failed to hack encryption...')
-        else:
-            print('Copying hacked message to clipboard...')
-            print(hackedMessage)
+
     def decrypt(self, text):
         # Brute-force by looping through every possible key.
-        print(len(text))
-        for key in range(1, len(text)):
-            decryptedText = self.decryptMessage(key, text)
-            print(decryptedText)
-            if self.lc.checkLanguage(decryptedText):
-                print("this is english according to lc")
-                return {"lc": self.lc, "IsPlaintext?": True, "Plaintext": decryptedText, "Cipher": "Transposition", "Extra Information": f"The key used is {key}"}
-        print("finished transposition")
-        
-        return {"lc": self.lc, "IsPlaintext?": False, "Plaintext": None, "Cipher": "Transposition", "Extra Information": None}
+        decryptedText = self.hackTransposition("""ehlol ym aftehrh ellom ym ohteXrX""")        
     def getName(self):
         return "Transposition"
     def hackTransposition(self, message):
-        print('Attempting to hack message...')
-        print('Press CTRL-C on Windows or CTRL-D on macOS or Linux to cancel....')
+        print('Hacking...')
+    
+        # Python programs can be stopped at any time by pressing Ctrl-C (on
+        # Windows) or Ctrl-D (on Mac and Linux)
     
-        # Loop over every key
+        # brute-force by looping through every possible key
         for key in range(1, len(message)):
-            print('Attempting key #%s' % (key))
-            if key >= 10:
-                return None
     
-            decryptedText = self.decryptMessage(key, message)
-            print('Key %s: %s' % (key, decryptedText[:100]))
-            #if self.lc.checkLanguage(message):
-                # Ask if this is correct decryption!!!
- 
-        # If hack failed
-        return None
+            decryptedText = self.transpositionDecrypt.decryptMessage(key, message)
+    
+            #if self.lc.checkLanguage(decryptedText):
+                # Check with user to see if the decrypted key has been found.
+            if self.lc.checkLanguage(decryptedText):
+                return {"lc": self.lc, "IsPlaintext?": True, "Plaintext": decryptedText, "Cipher": "Transposition", "Extra Information": f"The key is {key}"}
+        return {"lc": self.lc, "IsPlaintext?": False, "Plaintext": None, "Cipher": "Transposition", "Extra Information": None}
     def decryptMessage(self, key, message):
-        # Simulate columns and rows of the grid the plaintext was written on
-        numColumns = int(math.ceil(len(message) / float(key)))
-        numRows = key
-        numShadedBoxes = (numColumns * numRows) - len(message)
+        # The transposition decrypt function will simulate the "columns" and
+        # "rows" of the grid that the plaintext is written on by using a list
+        # of strings. First, we need to calculate a few values.
+    
+        # The number of "columns" in our transposition grid:
+        numOfColumns = math.ceil(len(message) / key)
+        # The number of "rows" in our grid will need:
+        numOfRows = key
+        # The number of "shaded boxes" in the last "column" of the grid:
+        numOfShadedBoxes = (numOfColumns * numOfRows) - len(message)
     
-        # Each string in plaintext reprsents a column in the grid
-        plaintext = [''] * numColumns
+        # Each string in plaintext represents a column in the grid.
+        plaintext = [''] * numOfColumns
     
-        # The column and row variables point to the grid location of the next char 
-        # in the encrypted message
-        column = 0
+        # The col and row variables point to where in the grid the next
+        # character in the encrypted message will go.
+        col = 0
         row = 0
     
-        for character in message:
-            plaintext[column] += character
-            column += 1
+        for symbol in message:
+            plaintext[col] += symbol
+            col += 1 # point to next column
     
-            # If no more columns or empty bos, move to first column of next row
-            if(column == numColumns) or (column == numColumns - 1 and row >= numRows - numShadedBoxes):
-                column = 0
+            # If there are no more columns OR we're at a shaded box, go back to
+            # the first column and the next row.
+            if (col == numOfColumns) or (col == numOfColumns - 1 and row >= numOfRows - numOfShadedBoxes):
+                col = 0
                 row += 1
     
-        return''.join(plaintext)
+        return ''.join(plaintext)
+                
 
 if __name__ == '__main__':
     t = Transposition("a")
