@@ -387,30 +387,6 @@ def arg_parsing(args) -> Optional[dict]:
     return config
 
 
-def main(config: Dict[str, object] = None, text: str = None) -> Optional[dict]:
-
-    """Function to deal with arguments. Either calls with args or not. Makes Pytest work.
-
-    It gets the arguments in the function definition using locals()
-    if withArgs is True, that means this is being called with command line args
-    so go to arg_parsing() to get those args
-    we then update locals() with the new command line args and remove "withArgs"
-    This function then calls call_encryption(**result) which passes our dict of args
-    to the function as its own arguments using dict unpacking.
-    
-        Returns:
-            The output of the decryption.
-    """
-    if text is not None:
-        config["ctext"] = text
-        config["text"] = text
-
-    # Now we have working arguments, we can expand it and pass it to the Ciphey constructor
-    cipher_obj = Ciphey(config)
-    # print(cipher_obj.ctext)
-    return cipher_obj.decrypt()
-
-
 @click.command()
 @click.option(
     "-t", "--text", help="The ciphertext you want to decrypt.", type=str,
@@ -457,7 +433,7 @@ def main(config: Dict[str, object] = None, text: str = None) -> Optional[dict]:
 )
 @click.argument("text_stdin", callback=get_name, required=False)
 @click.argument("file_stdin", type=click.File("rb"), required=False)
-def click_parsing(
+def main(
     text,
     greppable,
     verbose,
@@ -471,7 +447,7 @@ def click_parsing(
     text_stdin,
     file_stdin,
     config: Dict[str, object] = None,
-):
+) -> Optional[dict]:
     """Ciphey - Automated Decryption Tool
     
     Documentation: 
@@ -487,9 +463,19 @@ def click_parsing(
         Basic Usage: ciphey -t "aGVsbG8gbXkgbmFtZSBpcyBiZWU="
         
     """
-    """HARLAN or other contribs. The above text is printed upon help menu being called"""
 
-    # We must fill in the arguments if they are not provided
+    """Function to deal with arguments. Either calls with args or not. Makes Pytest work.
+
+    It gets the arguments in the function definition using locals()
+    if withArgs is True, that means this is being called with command line args
+    so go to arg_parsing() to get those args
+    we then update locals() with the new command line args and remove "withArgs"
+    This function then calls call_encryption(**result) which passes our dict of args
+    to the function as its own arguments using dict unpacking.
+    
+        Returns:
+            The output of the decryption.
+    """
 
     if config is None:
         config = locals()
@@ -498,16 +484,36 @@ def click_parsing(
         if config is None:
             return None
 
-    if config["text"] is None:
-        if file_stdin is not None:
-            config["text "] = file_stdin.read().decode("utf-8")
-        elif text_stdin is not None:
-            config["text "] = text_stdin
-        else:
-            print("No inputs were given to Ciphey. Run ciphey --help")
-            return None
-    print(text)
-    return main(config)
+        if config["ctext"] is None:
+            if file_stdin is not None:
+                config["text "] = file_stdin.read().decode("utf-8")
+            elif text_stdin is not None:
+                config["text "] = text_stdin
+            else:
+                print("No inputs were given to Ciphey. Run ciphey --help")
+                return None
+
+
+    return main_decrypt(config)
+
+    # Now we have working arguments, we can expand it and pass it to the Ciphey constructor
+
+
+def main_decrypt(config: Dict[str, object] = None) -> Optional[dict]:
+    """Calls the decrypt, acts as a 2nd main
+
+    The problem is that Click fails to run when importing and using main()
+
+    If I make a new function for Click, I have to change so much just to make it work.
+
+    If I make a new function for using the default config, and acting as a 2nd main -- I have to change less
+    Thus, this function exists."""
+    if config is None:
+        print("No config file.")
+        exit(1)
+
+    cipher_obj = Ciphey(config)
+    return cipher_obj.decrypt()
 
 
 if __name__ == "__main__":
