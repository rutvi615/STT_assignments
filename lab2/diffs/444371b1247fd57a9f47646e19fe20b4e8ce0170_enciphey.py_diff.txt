@@ -14,32 +14,32 @@ class encipher:
 
     """Generates encrypted text. Used for the NN and test_generator"""
 
-    def __init__(self):
+    def __init__(self):  # pragma: no cover
         """Inits the encipher object """
         self.text = self.read_text()[0:200]
         self.MAX_SENTENCE_LENGTH = 1
         # ntlk.download("punkt")
-        self.crypto = encipher_crypto.encipher_crypto()
+        self.crypto = encipher_crypto()
 
-    def read_text(self):
+    def read_text(self):  # pragma: no cover
         f = open("hansard.txt", encoding="ISO-8859-1")
         x = f.read()
         splits = nltk.tokenize.sent_tokenize(x)
         return splits
 
-    def getRandomSentence(self):
+    def getRandomSentence(self):  # pragma: no cover
         return TreebankWordDetokenizer().detokenize(
             random.sample(self.text, random.randint(1, self.MAX_SENTENCE_LENGTH))
         )
 
-    def getRandomEncryptedSentence(self):
+    def getRandomEncryptedSentence(self):  # pragma: no cover
         sents = self.getRandomSentence()
 
         sentsEncrypted = self.crypto.randomEncrypt(sents)
         return {"PlainText Sentences": sents, "Encrypted Texts": sentsEncrypted}
 
 
-class encipher_crypto:
+class encipher_crypto:  # pragma: no cover
 
     """Holds the encryption functions
     can randomly select an encryption function  use on text
@@ -50,35 +50,34 @@ class encipher_crypto:
 
     Uses Cyclic3's module  generate psuedo random text"""
 
-    def __init__(self):
-        """DO:  be defined. """
-        # self.methods = [
-        #     self.Base64,
-        #     self.Ascii,
-        #     self.Base16,
-        #     self.Base32,
-        #     self.Binary,
-        #     self.Hex,
-        #     self.MorseCode,
-        #     self.Reverse,
-        #     self.Vigenere,
-        # ]
-        self.methods = [self.Vigenere]
+    def __init__(self):  # pragma: no cover
+        self.methods = [
+            self.Base64,
+            self.Ascii,
+            self.Base16,
+            self.Base32,
+            self.Binary,
+            self.Hex,
+            self.MorseCode,
+            self.Reverse,
+            self.Vigenere,
+        ]
         self.morse_dict = dict(cipheydists.get_charset("morse"))
         self.letters = string.ascii_lowercase
         self.group = cipheydists.get_charset("english")["lcase"]
 
-    def random_key(self, text) -> str:
+    # pragma: no cover
+    def random_key(self, text) -> str:  # pragma: no cover
         if len(text) < 8:
             length = 3
         else:
             length = 8
         return self.random_string(length)
 
-    def random_string(self, length) -> str:
+    def random_string(self, length) -> str:  # pragma: no cover
         return "".join(random.sample(self.letters, length))
 
-    def randomEncrypt(self, text: str) -> str:
+    def randomEncrypt(self, text: str) -> str:  # pragma: no cover
         """Randomly encrypts string with an encryption"""
         func__use = random.choice(self.methods)
         encryptedText = func__use(text)
@@ -86,7 +85,7 @@ class encipher_crypto:
 
         return {"PlainText": text, "EncryptedText": encryptedText, "CipherUsed": name}
 
-    def Base64(self, text: str) -> str:
+    def Base64(self, text: str) -> str:  # pragma: no cover
         """Turns text in base64 using Python libray
 
             args:
@@ -96,7 +95,7 @@ class encipher_crypto:
                 text -> as base 64"""
         return base64.b64encode(bytes(text, "utf-8"))
 
-    def Caesar(self, s, k):
+    def Caesar(self, s, k):  # pragma: no cover
         """Iterates through each letter and constructs the cipher text"""
         new_message = ""
         facr = k % 26
@@ -104,14 +103,14 @@ class encipher_crypto:
             new_message += self.apply_rotation(c, facr)
         return new_message
 
-    def apply_rotation(self, c, facr):
+    def apply_rotation(self, c, facr):  # pragma: no cover
         """Applies a shift of facr  the letter denoted by c"""
         if c.isalpha():
             lower = ord("A") if c.isupper() else ord("a")
             c = chr(lower + ((ord(c) - lower + facr) % 26))
         return c
 
-    def Base32(self, text: str) -> str:
+    def Base32(self, text: str) -> str:  # pragma: no cover
         """Turns text in base64 using Python libray
 
             args:
@@ -121,7 +120,7 @@ class encipher_crypto:
                 text -> as base 64"""
         return base64.b32encode(bytes(text, "utf-8"))
 
-    def Base16(self, text: str) -> str:
+    def Base16(self, text: str) -> str:  # pragma: no cover
         """Turns text in base64 using Python libray
 
             args:
@@ -131,17 +130,18 @@ class encipher_crypto:
                 text -> as base 64"""
         return base64.b16encode(bytes(text, "utf-8"))
 
-    def Binary(self, text: str) -> str:
+    def Binary(self, text: str) -> str:  # pragma: no cover
         return " ".join(format(ord(x), "b") for x in text)
 
-    def Ascii(self, text: str) -> str:
+    # pragma: no cover
+    def Ascii(self, text: str) -> str:  # pragma: no cover
         res = [ord(c) for c in text]
         return " ".join([str(x) for x in res])
 
-    def Hex(self, text: str) -> str:
+    def Hex(self, text: str) -> str:  # pragma: no cover
         return binascii.hexlify(text.encode()).decode("utf-8")
 
-    def MorseCode(self, text: str) -> str:
+    def MorseCode(self, text: str) -> str:  # pragma: no cover
         morse = []
         for i in text:
             m = self.morse_dict.get(i.upper())
